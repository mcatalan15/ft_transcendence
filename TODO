<!-- How It Works

    Initial Authentication: Upon successful authentication, the server issues a JWT as it normally would. This token contains a unique session identifier (session ID).
	-> Backend issues the JWT from the JWT_SECRET passed from .env, sends it to frontend which keeps it in local storage(?).

    Session Storage: The server stores the session data associated with this session ID in a server-side session store. This data can include user permissions, roles, and other session-specific details.
	-> Along with JWT, backend sends username, id, profile info etc. Enables language preference (but in localStorage)

    Validation and Session Data Retrieval: Each time a user makes a request with a JWT, the server validates the JWT and then uses the session ID within it to retrieve the corresponding session data from the server-side store.
	-> Use JWT along with Middleware functions to protect API routes everytime the frontend makes a request to the backend.

    Flexibility in Session Management: This approach allows the server to invalidate sessions, change session data, and handle logouts more effectively than with stateless JWTs alone.
	-> Integrate JWT in the login/logout processes, languageSwitcher, etc.
	
-->

<!-- # Preventing SQL Injection in SQLite

I see you're already implementing the most important protection against SQL injection - parameterized queries with placeholder values. This is excellent! Let's review SQL injection prevention techniques:

## What You're Doing Right

```javascript
const query = `INSERT INTO users (username, email, password, provider) VALUES (?, ?, ?, ?)`;
const params = [username, email, hashedPassword, provider];
db.run(query, params, function(err) {
  // callback code
});
```

This pattern:
1. ✅ Separates SQL code from data
2. ✅ Uses `?` placeholders
3. ✅ Passes parameters as an array

## Why This Works

When you use parameterized queries, the SQLite driver:
- Escapes special characters
- Handles quoting automatically
- Prevents attackers from changing the structure of your SQL

## Additional Best Practices

3. **Explicit Column Lists**: Never use `SELECT *` in production:
   ```javascript
   // Instead of SELECT *
   const query = `SELECT id, username, email FROM users WHERE username = ?`;
   ```

4. **Error Messages**: Don't expose detailed error info to clients:
   ```javascript
   if (err) {
     console.error('[DB ERROR]', err); // Log the full error internally
     reject(new Error('Database error')); // Send generic message to client
   }
   ```

5. **Prepared Statements**: For repeated queries:
   ```javascript
   const stmt = db.prepare(`SELECT id FROM users WHERE username = ?`);
   // later
   stmt.get(username, callback);
   // when done
   stmt.finalize();
   ```